"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceEval = exports.isError = exports.evaluate = exports.checkSyntax = exports.isList = exports.parse = void 0;
function parse(rules, primitives) {
    let ast;
    try {
        ast = JSON.parse(rules);
    }
    catch (x) {
        return { message: "rules syntax error" };
    }
    try {
        if (checkSyntax(ast, primitives)) {
            return ast;
        }
        // we should never get a false result, but this satisfies the compiler
        return { message: "error in syntax checker" };
    }
    catch (e) {
        if (isError(e)) {
            return e;
        }
        return { message: `unexpected error checking AST: ${JSON.stringify(e)}` };
    }
}
exports.parse = parse;
function isList(ast) {
    return Array.isArray(ast);
}
exports.isList = isList;
function checkSyntax(ast, primitives) {
    checkSyntaxInner(ast, primitives);
    // Since there can be different reasons for the AST being invalid we use
    // exceptions instead of proper true | false branches. This lets us capture
    // messages in the caller.
    return true;
}
exports.checkSyntax = checkSyntax;
function checkSyntaxInner(ast, primitives) {
    switch (typeof ast) {
        case "number":
            return;
        case "string":
            return;
        case "boolean":
            return;
    }
    if (Array.isArray(ast)) {
        const car = ast[0];
        if (typeof car != "string") {
            throw { message: `can only apply strings, ${car} is not a string` };
        }
        if (primitives.indexOf(car) < 0) {
            throw { message: `${car} is not a primitive` };
        }
        const cdr = ast.slice(1);
        for (const elem of cdr) {
            checkSyntaxInner(elem, primitives);
        }
        return;
    }
    throw { message: `rules syntax error at ${JSON.stringify(ast)}` };
}
function evaluate(ast, env, primitives) {
    switch (typeof ast) {
        case "number":
            return ast;
        case "string":
            return ast;
        case "boolean":
            return ast;
        case "object":
            if (ast instanceof Array && typeof ast[0] == "string") {
                return evalApply(ast[0], ast.slice(1), env, primitives);
            }
    }
    return { message: `cannot evaluate ${ast}` };
}
exports.evaluate = evaluate;
function evalApply(head, args, env, primitives) {
    const prim = primitives[head];
    if (!prim) {
        return { message: `${head} is not a primitive` };
    }
    try {
        const evaledArgs = [];
        for (const arg of args) {
            const a = evaluate(arg, env, primitives);
            if (isError(a)) {
                return a;
            }
            evaledArgs.push(a);
        }
        return prim(evaledArgs, env);
    }
    catch {
        return { message: `error applying primitive ${head}` };
    }
}
function isError(x) {
    return x.message !== undefined;
}
exports.isError = isError;
/**
 * Trace the evaluation of the given rules expression.
 *
 * @param ast the expression to evaluate
 * @param env the environment to evaluate in
 * @param primitives implementations of functions that can be called, can refer to the environment
 * @returns the given ast, each node annotated with their partial result
 */
function traceEval(ast, env, primitives) {
    if (Array.isArray(ast) && typeof ast[0] == "string") {
        const symbol = ast[0];
        const args = ast.slice(1);
        const value = evalApply(symbol, args, env, primitives);
        // this is not very efficient, but the tracing is for previews/debugging only
        // and this implementation is simple
        const tracedArgs = args.map((arg) => traceEval(arg, env, primitives));
        // returns the same ast with partial results injected
        return [{ call: symbol, result: value }, ...tracedArgs];
    }
    return evaluate(ast, env, primitives);
}
exports.traceEval = traceEval;
//# sourceMappingURL=rules-engine.js.map