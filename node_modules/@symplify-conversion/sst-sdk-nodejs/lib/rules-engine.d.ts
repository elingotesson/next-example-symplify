export declare type Expr = Atom | List;
export declare type Atom = string | number | boolean;
export declare type List = Array<Expr>;
/**
 * Evaluating rules can yield a runtime error.
 */
export declare type RulesEngineError = {
    message: string;
};
/**
 * The environment is passed in from the outside when evaluating rules.
 */
export declare type Environment = {
    attributes: Record<string, Atom>;
};
/**
 * Primitive functions can be applied when evaluating, they can have arguemnts
 * and have access to the environment.
 */
export declare type PrimitiveFn = (args: Atom[], env: Environment) => Atom | RulesEngineError;
export declare function parse(rules: string, primitives: string[]): Expr | RulesEngineError;
export declare function isList(ast: Expr): ast is List;
export declare function checkSyntax(ast: unknown, primitives: string[]): ast is Expr;
export declare function evaluate(ast: Expr, env: Environment, primitives: Record<string, PrimitiveFn>): Atom | RulesEngineError;
export declare function isError(x: unknown): x is RulesEngineError;
export declare type TracedExpr = TracedAtom | TracedList;
export declare type TracedAtom = TracedApply | RulesEngineError | Atom;
export declare type TracedApply = {
    call: string;
    result: TracedAtom;
};
export declare type TracedList = Array<TracedExpr>;
/**
 * Trace the evaluation of the given rules expression.
 *
 * @param ast the expression to evaluate
 * @param env the environment to evaluate in
 * @param primitives implementations of functions that can be called, can refer to the environment
 * @returns the given ast, each node annotated with their partial result
 */
export declare function traceEval(ast: Expr, env: Environment, primitives: Record<string, PrimitiveFn>): TracedExpr | RulesEngineError;
