"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfigJSON = exports.restoreAudience = exports.doesAudienceApply = exports.findVariationForVisitor = exports.findProjectWithName = exports.findVariationWithID = exports.PrivacyMode = void 0;
const audience_1 = require("./audience");
const hash_1 = require("./hash");
const rules_engine_1 = require("./rules-engine");
var PrivacyMode;
(function (PrivacyMode) {
    PrivacyMode[PrivacyMode["DEFAULT"] = 0] = "DEFAULT";
    PrivacyMode[PrivacyMode["OPTIN_TRACKING"] = 1] = "OPTIN_TRACKING";
    PrivacyMode[PrivacyMode["OPTIN_EVERYTHING"] = 2] = "OPTIN_EVERYTHING";
})(PrivacyMode = exports.PrivacyMode || (exports.PrivacyMode = {}));
/**
 * Look up the variation with the given ID in the given project.
 */
function findVariationWithID(project, variationID) {
    for (const variation of project.variations) {
        if (variation.id === variationID) {
            return variation;
        }
    }
    return null;
}
exports.findVariationWithID = findVariationWithID;
/**
 * Look up the project with the given name, regardless of ID or active state.
 */
function findProjectWithName(config, projectName) {
    for (const project of config.projects) {
        if (project.name === projectName) {
            return project;
        }
    }
    return null;
}
exports.findProjectWithName = findProjectWithName;
/**
 * Allocate an active variation for the visitor in the given project.
 *
 * @returns null if the visitor ID is empty or the project or variation is not active
 */
function findVariationForVisitor(project, visitorID) {
    if (!visitorID || project.state !== "active") {
        return null;
    }
    const hashKey = `${visitorID}:${project.id}`;
    const hash = (0, hash_1.hashInWindow)(hashKey, 100);
    let pointer = 0;
    for (const variation of project.variations) {
        pointer += variation.weight;
        if (hash <= pointer) {
            return variation.state === "active" ? variation : null;
        }
    }
    return null;
}
exports.findVariationForVisitor = findVariationForVisitor;
function doesAudienceApply(project, attributes, logger) {
    if (!project.audience) {
        // no audience setup means always true
        return true;
    }
    const result = project.audience.eval({ attributes });
    if ((0, rules_engine_1.isError)(result)) {
        logger.warn(`audience check failed: ${result.message}`);
        return false;
    }
    return result;
}
exports.doesAudienceApply = doesAudienceApply;
function restoreAudience(cfg) {
    if (cfg.audience_rules) {
        // If we refactor the Audience constructor we can avoid this extra stringify, but
        // since we only construct Project instances on config load it's not performance sensitive.
        const audienceJSON = JSON.stringify(cfg.audience_rules);
        cfg.audience = new audience_1.Audience(audienceJSON);
    }
}
exports.restoreAudience = restoreAudience;
function parseConfigJSON(json) {
    const BOM = /^\xEF\xBB\xBF/;
    const cleanJSON = json.trimStart().replace(BOM, "");
    const config = JSON.parse(cleanJSON);
    for (const project of config.projects) {
        restoreAudience(project);
    }
    return config;
}
exports.parseConfigJSON = parseConfigJSON;
//# sourceMappingURL=project.js.map