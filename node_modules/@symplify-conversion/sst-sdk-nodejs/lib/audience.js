"use strict";
//
// See Audience.md in docs/
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.primitives = exports.Audience = void 0;
const rules_engine_1 = require("./rules-engine");
/**
 * Audience contains rules to be evaluated for activating projects.
 */
class Audience {
    /**
     * Create a new Audience with the given rules.
     *
     * @throws AudienceError if the rules are invalid
     * @param rules JSON string describing the audience rules, see docs/Audience.md
     */
    constructor(rules) {
        const result = (0, rules_engine_1.parse)(rules, Object.keys(exports.primitives));
        if ((0, rules_engine_1.isError)(result)) {
            throw result;
        }
        if (!(0, rules_engine_1.isList)(result)) {
            throw { message: "AST root must be a list" };
        }
        this.rules = result;
    }
    /**
     * eval interprets the rules in the given environment, and returns true if
     * the audience matches.
     */
    eval(env) {
        const result = (0, rules_engine_1.evaluate)(this.rules, env, exports.primitives);
        if ((0, rules_engine_1.isError)(result)) {
            return result;
        }
        if (!(typeof result == "boolean")) {
            return { message: `audience result was not boolean (${result})` };
        }
        return result;
    }
    /**
     * trace interprets the rules in the given environment, and annotates the
     * rules with partial values.
     */
    trace(env) {
        const result = (0, rules_engine_1.traceEval)(this.rules, env, exports.primitives);
        if (!Array.isArray(result)) {
            return { message: `audience trace failed (expected a list, but got ${result})` };
        }
        return result;
    }
}
exports.Audience = Audience;
function stringFun(a, b, op) {
    if (typeof a != "string" || typeof b != "string") {
        return { message: "expected string arguments" };
    }
    return op(a, b);
}
function numberFun(a, b, op) {
    if (typeof a != "number" || typeof b != "number") {
        return { message: "expected number arguments" };
    }
    return op(a, b);
}
exports.primitives = {
    // boolean operations
    not: (args) => {
        const [arg] = args;
        if (typeof arg == "boolean") {
            return !arg;
        }
        return { message: `${arg} is not a boolean` };
    },
    all: (args) => {
        for (const arg of args) {
            if (!(typeof arg == "boolean")) {
                return { message: `${arg} is not a boolean` };
            }
            if (!arg) {
                return false;
            }
        }
        return true;
    },
    any: (args) => {
        for (const arg of args) {
            if (!(typeof arg == "boolean")) {
                return { message: `${arg} is not a boolean` };
            }
            if (arg) {
                return true;
            }
        }
        return false;
    },
    // string comparisons
    equals: (args) => stringFun(args[0], args[1], (a, b) => a == b),
    contains: (args) => stringFun(args[0], args[1], (a, b) => a.includes(b)),
    matches: (args) => stringFun(args[0], args[1], (a, b) => new RegExp(b).test(a)),
    // number comparisons
    "==": (args) => numberFun(args[0], args[1], (a, b) => a == b),
    "!=": (args) => numberFun(args[0], args[1], (a, b) => a != b),
    "<": (args) => numberFun(args[0], args[1], (a, b) => a < b),
    "<=": (args) => numberFun(args[0], args[1], (a, b) => a <= b),
    ">": (args) => numberFun(args[0], args[1], (a, b) => a > b),
    ">=": (args) => numberFun(args[0], args[1], (a, b) => a >= b),
    // custom attribute getters
    "number-attribute": (args, env) => getInEnvNumber(args[0], env),
    "string-attribute": (args, env) => getInEnvString(args[0], env),
    "bool-attribute": (args, env) => getInEnvBool(args[0], env),
};
function getInEnvNumber(name, env) {
    if (typeof name != "string") {
        return { message: "can only look up string names" };
    }
    const val = env.attributes[name];
    if (typeof val != "number") {
        return { message: `'${name}' is not a number` };
    }
    return val;
}
function getInEnvString(name, env) {
    if (typeof name != "string") {
        return { message: "can only look up string names" };
    }
    const val = env.attributes[name];
    if (typeof val != "string") {
        return { message: `'${name}' is not a string` };
    }
    return val;
}
function getInEnvBool(name, env) {
    if (typeof name != "string") {
        return { message: "can only look up string names" };
    }
    const val = env.attributes[name];
    if (typeof val != "boolean") {
        return { message: `'${name}' is not a boolean` };
    }
    return val;
}
//# sourceMappingURL=audience.js.map